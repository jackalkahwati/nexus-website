#!/usr/bin/env node
const fs = require('fs');
const path = require('path');
const readline = require('readline');
const { execSync } = require('child_process');

// Colors for console output
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  dim: '\x1b[2m',
  underscore: '\x1b[4m',
  blink: '\x1b[5m',
  reverse: '\x1b[7m',
  hidden: '\x1b[8m',
  black: '\x1b[30m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
  white: '\x1b[37m',
};

// Environment files
const envExamplePath = path.join(__dirname, '..', '.env.example');
const envLocalPath = path.join(__dirname, '..', '.env.local');
const envTestPath = path.join(__dirname, '..', '.env.test');

// Create readline interface
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

// Helper function to prompt user for input
const prompt = (question, defaultValue = '') => {
  return new Promise((resolve) => {
    const q = defaultValue 
      ? `${question} [${colors.dim}${defaultValue}${colors.reset}]: `
      : `${question}: `;
    
    rl.question(q, (answer) => {
      resolve(answer.trim() || defaultValue);
    });
  });
};

// Parse .env file into an object
const parseEnvFile = (filePath) => {
  if (!fs.existsSync(filePath)) {
    return {};
  }

  const content = fs.readFileSync(filePath, 'utf8');
  const env = {};
  
  content.split('\n').forEach((line) => {
    // Skip comments and empty lines
    if (line.startsWith('#') || !line.includes('=')) {
      return;
    }
    
    const [key, ...values] = line.split('=');
    env[key.trim()] = values.join('=').trim();
  });
  
  return env;
};

// Generate .env file from template and user input
const generateEnvFile = async (templatePath, outputPath, isTest = false) => {
  const template = parseEnvFile(templatePath);
  const existing = fs.existsSync(outputPath) ? parseEnvFile(outputPath) : {};
  const result = {};
  
  console.log(`\n${colors.cyan}${colors.bright}Configuring ${isTest ? 'Test ' : ''}Environment Variables${colors.reset}\n`);
  
  // Process each variable in the template
  for (const [key, defaultValue] of Object.entries(template)) {
    // Skip comments and sections
    if (key.startsWith('#')) {
      result[key] = defaultValue;
      continue;
    }
    
    // Skip empty lines
    if (!key.trim()) {
      result[key] = '';
      continue;
    }
    
    // Skip section headers
    if (key.startsWith('=') || key.startsWith('[')) {
      result[key] = defaultValue;
      console.log(`\n${colors.magenta}${defaultValue}${colors.reset}`);
      continue;
    }
    
    // Get existing value or use template default
    const currentValue = existing[key] !== undefined ? existing[key] : defaultValue;
    
    // For test environment, use test-specific values
    if (isTest && key.endsWith('_DATABASE_URL')) {
      result[key] = template.TEST_DATABASE_URL || 'postgresql://test:test@localhost:5432/nexus_core_test?schema=public';
      continue;
    }
    
    // Skip sensitive values in test environment
    if (isTest && (key.includes('SECRET') || key.includes('KEY') || key.includes('PASSWORD'))) {
      result[key] = `test_${key.toLowerCase()}`;
      continue;
    }
    
    // Prompt user for input
    const value = await prompt(`  ${key}`, currentValue);
    result[key] = value || '';
  }
  
  // Generate file content
  let content = `# Auto-generated by setup-env.js\n# Generated at: ${new Date().toISOString()}\n\n`;
  
  let currentSection = '';
  
  for (const [key, value] of Object.entries(result)) {
    // Handle section headers
    if (key.startsWith('=') || key.startsWith('[')) {
      if (currentSection) content += '\n';
      content += `\n${value}\n`;
      currentSection = value;
      continue;
    }
    
    // Skip empty lines
    if (!key.trim()) {
      content += '\n';
      continue;
    }
    
    // Skip comments
    if (key.startsWith('#')) {
      content += `${value}\n`;
      continue;
    }
    
    // Add variable
    content += `${key}=${value}\n`;
  }
  
  // Write to file
  fs.writeFileSync(outputPath, content, 'utf8');
  console.log(`\n${colors.green}✓ ${isTest ? 'Test ' : ''}Environment file created: ${outputPath}${colors.reset}\n`);
};

// Main function
const main = async () => {
  try {
    console.log(`${colors.cyan}${colors.bright}Nexus Core Environment Setup${colors.reset}\n`);
    
    // Create .env.local
    await generateEnvFile(envExamplePath, envLocalPath);
    
    // Create .env.test
    const createTestEnv = await prompt('Create test environment file (.env.test)?', 'yes');
    if (createTestEnv.toLowerCase().startsWith('y')) {
      await generateEnvFile(envExamplePath, envTestPath, true);
    }
    
    // Install dependencies if needed
    const installDeps = await prompt('Install dependencies with npm install?', 'yes');
    if (installDeps.toLowerCase().startsWith('y')) {
      console.log('\nInstalling dependencies...');
      execSync('npm install', { stdio: 'inherit' });
    }
    
    // Run database migrations
    const runMigrations = await prompt('Run database migrations?', 'yes');
    if (runMigrations.toLowerCase().startsWith('y')) {
      console.log('\nRunning database migrations...');
      execSync('npx prisma migrate dev --name init', { stdio: 'inherit' });
    }
    
    console.log(`\n${colors.green}✓ Setup complete!${colors.reset}`);
    console.log(`\nTo start the development server, run: ${colors.cyan}npm run dev${colors.reset}\n`);
    
  } catch (error) {
    console.error(`\n${colors.red}Error: ${error.message}${colors.reset}\n`);
    process.exit(1);
  } finally {
    rl.close();
  }
};

// Run the script
main();
